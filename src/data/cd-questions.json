[
  {
    "id": 1,
    "topic": "Lexical Analysis",
    "question": "Which of the following is the primary task of a lexical analyzer? [GATE CS 2007]",
    "options": {
      "a": "To build a parse tree.",
      "b": "To generate machine code.",
      "c": "To group characters into a stream of tokens.",
      "d": "To perform type checking."
    },
    "answer": "c",
    "explanation": "The lexical analyzer, or scanner, is the first phase of a compiler. Its main job is to read the source program as a stream of characters and group them into meaningful sequences called lexemes, producing a stream of tokens as output for the parser."
  },
  {
    "id": 2,
    "topic": "Parsing",
    "question": "Which of the following grammars is NOT an LL(1) grammar? [GATE CS 2008]",
    "options": {
      "a": "S → a S b | ε",
      "b": "S → S + a | a",
      "c": "S → a A, A → b",
      "d": "S → A a, A → b | ε"
    },
    "answer": "b",
    "explanation": "An LL(1) grammar must not be left-recursive. The grammar S → S + a | a is left-recursive because the non-terminal S appears as the first symbol on the right-hand side of its own production. Left recursion cannot be handled by top-down parsers like LL(1)."
  },
  {
    "id": 3,
    "topic": "Syntax Directed Translation",
    "question": "An inherited attribute is one whose value at a node in a parse tree is defined in terms of: [GATE CS 2011]",
    "options": {
      "a": "Attributes at the children of that node.",
      "b": "Attributes at that node itself.",
      "c": "Attributes at the parent and/or siblings of that node.",
      "d": "All of the above."
    },
    "answer": "c",
    "explanation": "In syntax-directed translation, an inherited attribute at a node is computed from attribute values at its parent, the node itself, or its siblings. This is in contrast to a synthesized attribute, which is computed from the attribute values of its children."
  },
  {
    "id": 4,
    "topic": "Code Optimization",
    "question": "Which of the following is a machine-independent code optimization technique? [GATE CS 2009]",
    "options": {
      "a": "Register allocation",
      "b": "Instruction scheduling",
      "c": "Common subexpression elimination",
      "d": "Peephole optimization"
    },
    "answer": "c",
    "explanation": "Machine-independent optimization is performed on the intermediate representation of the code and does not depend on the target machine's architecture. Common subexpression elimination, which finds and removes redundant computations, is a classic example. Register allocation and instruction scheduling are machine-dependent optimizations."
  },
  {
    "id": 5,
    "topic": "Parsing",
    "question": "YACC (Yet Another Compiler-Compiler) is a tool for generating: [GATE CS 2005]",
    "options": {
      "a": "A lexical analyzer.",
      "b": "An LALR parser.",
      "c": "An LL(1) parser.",
      "d": "An abstract syntax tree."
    },
    "answer": "b",
    "explanation": "YACC is a standard parser generator tool. It takes a context-free grammar (specifically, one that is LALR(1)) as input and generates the C code for a parser that recognizes the language described by that grammar. LALR (Look-Ahead LR) is a type of bottom-up parser."
  },
  {
    "id": 6,
    "topic": "Lexical Analysis",
    "question": "The lexical analysis for a modern computer language like C is based on which of the following? [GATE CS 2010]",
    "options": {
      "a": "Context-free grammars",
      "b": "Pushdown automata",
      "c": "Regular expressions",
      "d": "Turing machines"
    },
    "answer": "c",
    "explanation": "The structure of tokens (like identifiers, keywords, numbers, operators) in a programming language can be described by regular expressions. These regular expressions are then used to automatically generate a lexical analyzer, which is essentially a finite automaton."
  },
  {
    "id": 7,
    "topic": "Parsing",
    "question": "A grammar is said to be ambiguous if: [GATE CS 2010]",
    "options": {
      "a": "It produces more than one string.",
      "b": "It has two or more parse trees for the same string.",
      "c": "It has two or more non-terminals.",
      "d": "It has a recursive production."
    },
    "answer": "b",
    "explanation": "Ambiguity is a property of a grammar, not a language. A grammar is ambiguous if there exists at least one string in the language that can be generated by two or more distinct parse trees (or leftmost/rightmost derivations)."
  },
  {
    "id": 8,
    "topic": "Intermediate Code",
    "question": "Which of the following is a form of intermediate code representation? [GATE CS 2008]",
    "options": {
      "a": "Assembly code",
      "b": "Machine code",
      "c": "Three-address code",
      "d": "Source code"
    },
    "answer": "c",
    "explanation": "Intermediate code is a representation of the source program that is between the high-level source and the low-level target machine code. Three-address code is a common form, where each instruction has at most three addresses (e.g., `x = y op z`). Other forms include syntax trees and postfix notation."
  },
  {
    "id": 9,
    "topic": "Code Optimization",
    "question": "The optimization technique that replaces `x = a*2` with `x = a << 1` is called: [GATE CS 2012]",
    "options": {
      "a": "Constant folding",
      "b": "Loop unrolling",
      "c": "Strength reduction",
      "d": "Code motion"
    },
    "answer": "c",
    "explanation": "Strength reduction is an optimization that replaces an expensive (stronger) operation with a cheaper (weaker) one. Multiplication by a power of 2 is a more expensive operation than a bitwise left shift, so replacing `a*2` with `a << 1` is a classic example of strength reduction."
  },
  {
    "id": 10,
    "topic": "Parsing",
    "question": "Which parsing technique is most powerful in terms of the class of grammars it can handle? [GATE CS 2011]",
    "options": {
      "a": "LL(1)",
      "b": "SLR",
      "c": "LALR",
      "d": "Canonical LR (CLR)"
    },
    "answer": "d",
    "explanation": "There is a hierarchy of power for bottom-up LR parsers: SLR is the least powerful, LALR is more powerful than SLR, and Canonical LR (CLR) is the most powerful. CLR can parse the largest class of context-free grammars among the LR family, but at the cost of having a very large parsing table."
  },
  {
    "id": 11,
    "topic": "Syntax Directed Translation",
    "question": "In a syntax-directed definition, if all attributes are synthesized attributes, the definition is called: [GATE CS 2007]",
    "options": {
      "a": "An S-attributed definition",
      "b": "An L-attributed definition",
      "c": "An inherited definition",
      "d": "A canonical definition"
    },
    "answer": "a",
    "explanation": "An S-attributed definition is a syntax-directed definition that uses only synthesized attributes. Synthesized attributes are computed from the attributes of the children of a node in the parse tree, allowing for a straightforward bottom-up evaluation."
  },
  {
    "id": 12,
    "topic": "Parsing",
    "question": "Consider the grammar: S → (L) | a, L → L,S | S. To make this grammar suitable for predictive parsing (LL(1)), what is the main problem to be addressed? [GATE CS 2004]",
    "options": {
      "a": "It is right-recursive.",
      "b": "It is ambiguous.",
      "c": "It is left-recursive.",
      "d": "It has epsilon productions."
    },
    "answer": "c",
    "explanation": "The production L → L,S is left-recursive because the non-terminal 'L' on the left side of the production also appears as the first symbol on the right side. LL(1) parsers, being top-down, cannot handle left recursion as it would lead to infinite recursion."
  },
  {
    "id": 13,
    "topic": "Phases of a Compiler",
    "question": "Symbol table management is primarily handled in which phase of the compiler? [GATE CS 2009]",
    "options": {
      "a": "Lexical Analysis",
      "b": "Syntax Analysis",
      "c": "Semantic Analysis",
      "d": "All of the above"
    },
    "answer": "d",
    "explanation": "The symbol table is a data structure used by the compiler to store information about identifiers. It is created and populated during Lexical and Syntax analysis (when identifiers are first encountered). It is heavily used and updated during Semantic Analysis (for type checking) and subsequent phases like code generation. So, it is managed across multiple phases."
  },
  {
    "id": 14,
    "topic": "Code Optimization",
    "question": "A 'basic block' in code optimization is a sequence of instructions where: [GATE CS 2010]",
    "options": {
      "a": "Control flow enters only at the beginning and leaves only at the end.",
      "b": "There are no loop structures.",
      "c": "All instructions are of the same type.",
      "d": "The code is machine-independent."
    },
    "answer": "a",
    "explanation": "A basic block is a fundamental concept in compiler optimization. It is a straight-line sequence of code with no branches in, except to the beginning, and no branches out, except at the end. This property makes basic blocks easy to analyze and optimize."
  },
  {
    "id": 15,
    "topic": "Parsing",
    "question": "A shift-reduce parser is a type of: [GATE CS 2006]",
    "options": {
      "a": "Top-down parser",
      "b": "Bottom-up parser",
      "c": "Predictive parser",
      "d": "Recursive descent parser"
    },
    "answer": "b",
    "explanation": "Shift-reduce parsers, such as LR, SLR, and LALR parsers, are bottom-up parsers. They work by 'shifting' input tokens onto a stack until the top of the stack matches the right-hand side of a grammar production, which is then 'reduced' to the corresponding non-terminal."
  },
  {
    "id": 16,
    "topic": "Lexical Analysis",
    "question": "The tool 'Lex' is used to generate: [GATE CS 2008]",
    "options": {
      "a": "A parser",
      "b": "A code optimizer",
      "c": "A lexical analyzer",
      "d": "A code generator"
    },
    "answer": "c",
    "explanation": "Lex is a standard tool on Unix-like systems for generating lexical analyzers (also known as scanners). It takes a set of regular expressions and corresponding actions as input and generates C code that can recognize the tokens described."
  },
  {
    "id": 17,
    "topic": "Parsing",
    "question": "For a context-free grammar, FIRST and FOLLOW sets are computed to construct the parsing table for which type of parser? [GATE CS 2013]",
    "options": {
      "a": "SLR",
      "b": "LALR",
      "c": "CLR",
      "d": "LL(1)"
    },
    "answer": "d",
    "explanation": "FIRST and FOLLOW sets are crucial for top-down parsing. An LL(1) parser uses these sets to create its predictive parsing table. The table tells the parser which production to apply based on the current non-terminal on the stack and the next input token (the '1' lookahead)."
  },
  {
    "id": 18,
    "topic": "Syntax Directed Translation",
    "question": "Which of the following is true about L-attributed definitions? [GATE CS 2014]",
    "options": {
      "a": "They can only use synthesized attributes.",
      "b": "They can be evaluated in a single depth-first traversal of the parse tree.",
      "c": "They are more powerful than S-attributed definitions.",
      "d": "Both b and c."
    },
    "answer": "d",
    "explanation": "L-attributed definitions are a superset of S-attributed definitions. They allow both synthesized attributes and inherited attributes, with the restriction that an inherited attribute for a symbol on the right side of a production can only depend on attributes of symbols to its left. This structure allows them to be conveniently evaluated during a single depth-first, left-to-right traversal of the parse tree. They are more powerful than S-attributed definitions because they can handle more types of dependencies."
  },
  {
    "id": 19,
    "topic": "Code Optimization",
    "question": "'Loop jamming' or 'loop fusion' is an optimization that: [GATE CS 2009]",
    "options": {
      "a": "Splits a single loop into multiple loops.",
      "b": "Combines adjacent loops into a single loop.",
      "c": "Moves code out of a loop.",
      "d": "Unrolls the loop."
    },
    "answer": "b",
    "explanation": "Loop fusion is a compiler optimization that combines two or more adjacent loops that have the same iteration space into a single loop. This can reduce loop overhead and improve cache performance by increasing data locality."
  },
  {
    "id": 20,
    "topic": "Parsing",
    "question": "A 'handle' in the context of a shift-reduce parser is: [GATE CS 2007]",
    "options": {
      "a": "The next input token to be shifted.",
      "b": "The top element of the stack.",
      "c": "The right-hand side of a production that is on top of the stack and can be reduced.",
      "d": "The non-terminal to be expanded."
    },
    "answer": "c",
    "explanation": "In bottom-up parsing, a 'handle' is a substring that matches the right-hand side of a production rule and whose reduction represents one step along the reverse of a rightmost derivation. In a shift-reduce parser, the handle always appears on top of the stack."
  },
  {
    "id": 21,
    "topic": "Phases of a Compiler",
    "question": "Which phase of the compiler checks for type mismatches? [GATE CS 2011]",
    "options": {
      "a": "Lexical Analysis",
      "b": "Syntax Analysis",
      "c": "Semantic Analysis",
      "d": "Code Generation"
    },
    "answer": "c",
    "explanation": "The Semantic Analysis phase is responsible for checking the semantic consistency of the source code. This includes type checking (e.g., ensuring you don't add a string to an integer), checking for undeclared variables, and making sure function call arguments match the function's definition."
  },
  {
    "id": 22,
    "topic": "Parsing",
    "question": "A recursive descent parser is a type of: [GATE CS 2008]",
    "options": {
      "a": "LL parser",
      "b": "LR parser",
      "c": "SLR parser",
      "d": "Operator-precedence parser"
    },
    "answer": "a",
    "explanation": "A recursive descent parser is a top-down parser that uses a set of recursive procedures to process the input. It is a way of implementing an LL parser, particularly one that does not use a table (though predictive parsers are a form of recursive descent that can be implemented with a table)."
  },
  {
    "id": 23,
    "topic": "Intermediate Code",
    "question": "The statement `x = y + z * w;` can be represented in three-address code as: [GATE CS 2013]",
    "options": {
      "a": "t1 = z*w; x = y+t1;",
      "b": "t1 = y+z; x = t1*w;",
      "c": "x = add y,z; x = mul x,w;",
      "d": "It cannot be represented in three-address code."
    },
    "answer": "a",
    "explanation": "Three-address code breaks down complex expressions into a sequence of simple instructions, each with at most one operator and three addresses. To evaluate `y + z * w`, the multiplication must be done first due to operator precedence. So, we first compute `t1 = z * w`, and then `x = y + t1`."
  },
  {
    "id": 24,
    "topic": "Code Optimization",
    "question": "An expression that has the same value every time a loop is executed can be moved outside the loop. This optimization is called: [GATE CS 2014]",
    "options": {
      "a": "Constant folding",
      "b": "Strength reduction",
      "c": "Loop invariant code motion",
      "d": "Loop unrolling"
    },
    "answer": "c",
    "explanation": "Loop invariant code motion is an optimization that identifies calculations inside a loop that produce the same result in every iteration (i.e., they are 'invariant'). It moves these calculations to a point just before the loop starts, avoiding redundant computation."
  },
  {
    "id": 25,
    "topic": "Parsing",
    "question": "The action of a parser upon finding a syntax error is to: [GATE CS 2009]",
    "options": {
      "a": "Halt and exit immediately.",
      "b": "Attempt to correct the error.",
      "c": "Report the error and attempt to recover to find more errors.",
      "d": "Ignore the error and continue."
    },
    "answer": "c",
    "explanation": "A modern compiler's parser doesn't just halt at the first error. It uses error recovery strategies (like panic mode or phrase-level recovery) to report the error in a meaningful way and then adjust its state so it can continue parsing the rest of the file. This allows it to detect and report multiple syntax errors in a single compilation run."
  },
  {
    "id": 26,
    "topic": "Lexical Analysis",
    "question": "What is a 'lexeme'? [GATE CS 2012]",
    "options": {
      "a": "The name of a token, like 'identifier'.",
      "b": "A pattern used to describe a token.",
      "c": "The actual sequence of characters in the source code that matches a token's pattern.",
      "d": "An error in the source code."
    },
    "answer": "c",
    "explanation": "A 'token' is a pair consisting of a token name and an optional attribute value (e.g., `<identifier, 'count'>`). A 'pattern' is a rule describing the set of lexemes that can represent a token (e.g., a regular expression). A 'lexeme' is the actual sequence of characters in the source program that is matched by the pattern for a token (e.g., the string 'count')."
  },
  {
    "id": 27,
    "topic": "Parsing",
    "question": "Shift-reduce conflicts can be of two types: [GATE CS 2008]",
    "options": {
      "a": "Shift-shift and reduce-reduce",
      "b": "Shift-reduce and reduce-reduce",
      "c": "Shift-shift and reduce-shift",
      "d": "Top-down and bottom-up"
    },
    "answer": "b",
    "explanation": "When constructing an LR parsing table, two types of conflicts can arise in a state. A 'shift-reduce' conflict occurs when the parser cannot decide whether to shift the next input token onto the stack or reduce a handle that is already on the stack. A 'reduce-reduce' conflict occurs when two or more different productions can be used to reduce the same handle on the stack."
  },
  {
    "id": 28,
    "topic": "Syntax Directed Translation",
    "question": "A parse tree is a: [GATE CS 2010]",
    "options": {
      "a": "Graphical representation of a derivation.",
      "b": "Data structure for storing tokens.",
      "c": "Representation of the optimized code.",
      "d": "Table used for parsing."
    },
    "answer": "a",
    "explanation": "A parse tree (or concrete syntax tree) is an ordered, rooted tree that graphically represents the syntactic structure of a string according to some context-free grammar. The internal nodes are labeled with non-terminals, and the leaf nodes are labeled with terminals."
  },
  {
    "id": 29,
    "topic": "Code Generation",
    "question": "Register allocation and assignment is a task of which phase? [GATE CS 2011]",
    "options": {
      "a": "Lexical Analysis",
      "b": "Syntax Analysis",
      "c": "Code Optimization",
      "d": "Code Generation"
    },
    "answer": "d",
    "explanation": "Register allocation is a crucial part of the Code Generation phase. The goal is to decide which variables should reside in the limited number of CPU registers at each point in the program to minimize memory access and speed up execution. It is often considered a sub-problem of code optimization but is fundamental to the final code generation step."
  },
  {
    "id": 30,
    "topic": "Parsing",
    "question": "A grammar G is LL(1) if and only if for any two distinct productions A → α | β: [GATE CS 2014]",
    "options": {
      "a": "FIRST(α) ∩ FIRST(β) = ∅",
      "b": "FIRST(α) = FOLLOW(A)",
      "c": "FIRST(α) ∩ FOLLOW(A) = ∅",
      "d": "Both a and c (if β can derive ε)"
    },
    "answer": "d",
    "explanation": "For a grammar to be LL(1), two conditions must be met for any non-terminal A with productions A → α | β. \n1. The sets of tokens that can start α and β must be disjoint: FIRST(α) ∩ FIRST(β) = ∅. \n2. If one of the productions can derive the empty string (ε), say β ⇒* ε, then the set of tokens that can start α must be disjoint from the set of tokens that can follow A: FIRST(α) ∩ FOLLOW(A) = ∅."
  },
  {
    "id": 31,
    "topic": "Phases of a Compiler",
    "question": "The output of a compiler is: [GATE CS 2009]",
    "options": {
      "a": "Source code",
      "b": "Object code or assembly code",
      "c": "A stream of tokens",
      "d": "A parse tree"
    },
    "answer": "b",
    "explanation": "A compiler is a program that translates source code written in a high-level programming language into a lower-level language. The final output is typically object code or assembly code, which can then be linked and executed by the target machine."
  },
  {
    "id": 32,
    "topic": "Parsing",
    "question": "Which of the following is a top-down parser? [GATE CS 2007]",
    "options": {
      "a": "Recursive descent parser",
      "b": "Shift-reduce parser",
      "c": "LR parser",
      "d": "LALR parser"
    },
    "answer": "a",
    "explanation": "Top-down parsers build the parse tree from the root (the start symbol) down to the leaves. Recursive descent parsing is a major category of top-down parsing. Shift-reduce, LR, and LALR are all types of bottom-up parsers."
  },
  {
    "id": 33,
    "topic": "Code Optimization",
    "question": "Peephole optimization is a form of: [GATE CS 2013]",
    "options": {
      "a": "Loop optimization",
      "b": "Local optimization",
      "c": "Global optimization",
      "d": "Machine-dependent optimization"
    },
    "answer": "b",
    "explanation": "Peephole optimization is a type of local optimization. It works by examining a short sequence of adjacent instructions (a 'peephole') in the generated code and replacing them with a shorter or faster sequence. It is often performed on the final target code, making it machine-dependent as well, but its scope is local."
  },
  {
    "id": 34,
    "topic": "Lexical Analysis",
    "question": "A finite automaton is used to recognize: [GATE CS 2008]",
    "options": {
      "a": "Context-free languages",
      "b": "Context-sensitive languages",
      "c": "Regular languages",
      "d": "Recursively enumerable languages"
    },
    "answer": "c",
    "explanation": "Finite automata (both deterministic and non-deterministic) are the theoretical models of computation that recognize the class of regular languages. They have a finite amount of memory, which is sufficient for recognizing patterns described by regular expressions."
  },
  {
    "id": 35,
    "topic": "Parsing",
    "question": "The process of removing left recursion from a grammar is essential for creating: [GATE CS 2011]",
    "options": {
      "a": "An SLR parser",
      "b": "An LL(1) parser",
      "c": "An LALR parser",
      "d": "Any LR parser"
    },
    "answer": "b",
    "explanation": "Top-down parsers, like recursive descent or LL(1) parsers, cannot handle grammars with left recursion because it would cause them to enter an infinite loop of recursive calls. Therefore, left recursion must be eliminated and replaced with right recursion before such a parser can be built."
  },
  {
    "id": 36,
    "topic": "Syntax Directed Translation",
    "question": "An Abstract Syntax Tree (AST) differs from a parse tree because it: [GATE CS 2014]",
    "options": {
      "a": "Represents the code more compactly, omitting unnecessary syntactic details.",
      "b": "Can only be built by a bottom-up parser.",
      "c": "Is generated by the lexical analyzer.",
      "d": "Contains every single token from the source code."
    },
    "answer": "a",
    "explanation": "A parse tree (or concrete syntax tree) represents the exact syntactic structure of the source code, including all terminals and non-terminals. An Abstract Syntax Tree (AST) is a more compact, abstract representation that omits intermediate nodes and syntactic details (like parentheses or semicolons) that are not essential for semantic analysis and code generation."
  },
  {
    "id": 37,
    "topic": "Phases of a Compiler",
    "question": "Linker is a program that: [GATE CS 2012]",
    "options": {
      "a": "Translates a program from a high-level language to machine language.",
      "b": "Takes object files and combines them into a single executable file.",
      "c": "Loads a program from disk into memory to run.",
      "d": "Checks the syntax of a program."
    },
    "answer": "b",
    "explanation": "The linker is a system program that takes one or more object files (produced by a compiler or assembler) and combines them into a single executable file, a library file, or another object file. Its main job is to resolve external references between object files."
  },
  {
    "id": 38,
    "topic": "Parsing",
    "question": "What is a 'reduce-reduce' conflict? [GATE CS 2009]",
    "options": {
      "a": "When the parser cannot decide whether to shift or reduce.",
      "b": "When the parser can apply two or more different productions to reduce the same handle.",
      "c": "When two different non-terminals can be reduced to the same terminal.",
      "d": "When a reduction leads to an infinite loop."
    },
    "answer": "b",
    "explanation": "A reduce-reduce conflict occurs in a state of an LR parser when the lookahead token does not provide enough information to decide which of two or more possible reductions to perform. This indicates an ambiguity in the grammar."
  },
  {
    "id": 39,
    "topic": "Code Optimization",
    "question": "The technique of reordering instructions to avoid pipeline stalls is called: [GATE CS 2010]",
    "options": {
      "a": "Instruction scheduling",
      "b": "Register allocation",
      "c": "Loop fusion",
      "d": "Strength reduction"
    },
    "answer": "a",
    "explanation": "Instruction scheduling is a machine-dependent optimization performed by the compiler to reorder instructions in a way that minimizes pipeline stalls caused by data dependencies, resource conflicts, or control hazards. The goal is to keep all stages of the pipeline busy."
  },
  {
    "id": 40,
    "topic": "Parsing",
    "question": "A grammar is not LALR(1) if its SLR(1) parsing table has a shift-reduce conflict, and the conflict cannot be resolved by the LALR lookahead sets. [GATE CS 2013]",
    "options": {
      "a": "True",
      "b": "False"
    },
    "answer": "a",
    "explanation": "This statement is true. LALR(1) parsers are created by merging states from the CLR(1) parser. This merging can sometimes introduce reduce-reduce conflicts that were not present in the CLR parser. LALR is more powerful than SLR because it uses more precise lookahead information (the FOLLOW set of the non-terminal) to resolve conflicts. If a conflict persists even with this more precise lookahead, the grammar is not LALR(1)."
  },
  {
    "id": 41,
    "topic": "Lexical Analysis",
    "question": "What is the role of a sentinel in lexical analysis? [GATE CS 2007]",
    "options": {
      "a": "To mark the end of the input file.",
      "b": "To mark the beginning of a token.",
      "c": "To speed up the checking for the end of a buffer.",
      "d": "To report an error."
    },
    "answer": "c",
    "explanation": "When a lexical analyzer reads input using a buffer, it has to perform two checks in its inner loop: one for the end of the lexeme and one for the end of the buffer. A sentinel is a special character (like EOF) placed at the end of the buffer. This allows the scanner to combine the two checks into one, as it will always find the sentinel at the end, simplifying the loop and making it faster."
  },
  {
    "id": 42,
    "topic": "Parsing",
    "question": "Operator-precedence parsing is a technique for parsing: [GATE CS 2008]",
    "options": {
      "a": "Any context-free grammar.",
      "b": "LL(1) grammars.",
      "c": "A small class of grammars called operator grammars.",
      "d": "Ambiguous grammars."
    },
    "answer": "c",
    "explanation": "Operator-precedence parsing is a type of bottom-up parsing that can be applied to a specific, restricted class of context-free grammars known as operator grammars. An operator grammar is one in which no production has two adjacent non-terminals on its right side. It works by using precedence relations between terminals."
  },
  {
    "id": 43,
    "topic": "Intermediate Code",
    "question": "A directed acyclic graph (DAG) is a useful data structure for: [GATE CS 2011]",
    "options": {
      "a": "Representing a parse tree.",
      "b": "Representing basic blocks and identifying common subexpressions.",
      "c": "Storing the symbol table.",
      "d": "Generating a lexical analyzer."
    },
    "answer": "b",
    "explanation": "A DAG is often used to represent the structure of a basic block. Each node represents a value, and nodes for common subexpressions are reused. This makes it a very effective data structure for identifying and eliminating common subexpressions within a basic block."
  },
  {
    "id": 44,
    "topic": "Code Optimization",
    "question": "Dead code elimination is a technique that: [GATE CS 2014]",
    "options": {
      "a": "Removes unreachable code.",
      "b": "Removes code that computes values that are never used.",
      "c": "Both a and b.",
      "d": "Removes redundant loops."
    },
    "answer": "c",
    "explanation": "Dead code refers to any code that does not affect the program's output. This includes unreachable code (code that can never be executed, like statements after a `return`) and code that produces results which are never used later in the program. Dead code elimination is the process of removing such code."
  },
  {
    "id": 45,
    "topic": "Parsing",
    "question": "The number of states in an SLR parser for a grammar G and in an LALR parser for G are: [GATE CS 2009]",
    "options": {
      "a": "Always the same.",
      "b": "SLR can have more states.",
      "c": "LALR can have more states.",
      "d": "Not related."
    },
    "answer": "a",
    "explanation": "Both SLR (Simple LR) and LALR (Look-Ahead LR) parsers are built upon the collection of LR(0) items. They use the same number of states. The difference between them lies in the lookahead symbols they use to make reduce decisions, which affects the parsing table, not the number of states. LALR is more powerful because it uses more precise lookaheads."
  },
  {
    "id": 46,
    "topic": "Syntax Directed Translation",
    "question": "A dependency graph is used to: [GATE CS 2012]",
    "options": {
      "a": "Determine the order of evaluation for attributes.",
      "b": "Show the structure of a program.",
      "c": "Find dependencies between source files.",
      "d": "Represent control flow."
    },
    "answer": "a",
    "explanation": "For a given parse tree, a dependency graph shows the flow of information between attribute instances. An edge from one attribute to another means the second attribute's value depends on the first. A topological sort of this graph gives a valid order for evaluating the attributes."
  },
  {
    "id": 47,
    "topic": "Phases of a Compiler",
    "question": "What is the primary role of a loader? [GATE CS 2013]",
    "options": {
      "a": "To translate assembly code to object code.",
      "b": "To combine object files into an executable.",
      "c": "To bring an executable file from disk into memory and start it running.",
      "d": "To optimize the executable file."
    },
    "answer": "c",
    "explanation": "The loader is an operating system utility that is responsible for loading programs into memory and preparing them for execution. Its tasks include allocation (finding memory space), linking (if dynamic linking is used), relocation (adjusting addresses), and loading the actual code and data."
  },
  {
    "id": 48,
    "topic": "Parsing",
    "question": "The grammar A → AA | (A) | ε is not suitable for predictive parsing because: [GATE CS 2008]",
    "options": {
      "a": "It is right-recursive.",
      "b": "It is ambiguous.",
      "c": "It is not context-free.",
      "d": "It has no terminals."
    },
    "answer": "b",
    "explanation": "This grammar (which generates balanced parentheses) is ambiguous. For example, the empty string ε can be derived as S->ε or S->SS->εε. A string like '()' can be derived as S->(A)->() or S->SS->(A)S->()ε->(). An LL(1) grammar must be unambiguous. The grammar is also left-recursive (A->AA), which is another reason it's not suitable."
  },
  {
    "id": 49,
    "topic": "Code Optimization",
    "question": "Which data flow analysis is used for live variable analysis? [GATE CS 2011]",
    "options": {
      "a": "Forward analysis",
      "b": "Backward analysis",
      "c": "Bi-directional analysis",
      "d": "It is not a data flow analysis problem."
    },
    "answer": "b",
    "explanation": "Live variable analysis determines for each point in a program, which variables may be used in the future. Since the liveness of a variable at a point depends on its future uses, the information flows backward from the exit of a basic block to its entry. Therefore, it is a backward data flow analysis problem."
  },
  {
    "id": 50,
    "topic": "Parsing",
    "question": "A handle is pruned from the right-hand side of a production in which parsing method? [GATE CS 2010]",
    "options": {
      "a": "LL(1)",
      "b": "Recursive Descent",
      "c": "LR (Bottom-up)",
      "d": "All of the above"
    },
    "answer": "c",
    "explanation": "Handle pruning is the core concept of bottom-up (shift-reduce) parsing, such as LR parsing. The parser shifts tokens onto a stack until a 'handle' (the right side of a production) appears on top. It then 'prunes' this handle by reducing it to the corresponding non-terminal."
  }
]